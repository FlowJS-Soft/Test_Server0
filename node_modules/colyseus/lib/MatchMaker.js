"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Utils_1 = require("./Utils");
const index_1 = require("./index");
const Protocol_1 = require("./Protocol");
const RegisteredHandler_1 = require("./matchmaker/RegisteredHandler");
const Room_1 = require("./Room");
const LocalPresence_1 = require("./presence/LocalPresence");
const Debug_1 = require("./Debug");
const Errors_1 = require("./Errors");
const LocalDriver_1 = require("./matchmaker/drivers/LocalDriver");
// remote room call timeouts
exports.REMOTE_ROOM_SHORT_TIMEOUT = Number(process.env.COLYSEUS_PRESENCE_SHORT_TIMEOUT || 2000);
class MatchMaker {
    constructor(presence, driver, processId) {
        this.handlers = {};
        this.exposedMethods = ['joinOrCreate', 'create', 'join', 'joinById'];
        this.allowedRoomNameChars = /([a-zA-Z_\-0-9]+)/gi;
        this.localRooms = {};
        this.isGracefullyShuttingDown = false;
        this.presence = presence || new LocalPresence_1.LocalPresence();
        this.driver = driver || new LocalDriver_1.LocalDriver();
        this.processId = processId;
    }
    joinOrCreate(roomName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let room = yield this.queryRoom(roomName, options);
            if (!room) {
                room = yield this.createRoom(roomName, options);
            }
            return this.reserveSeatFor(room, options);
        });
    }
    create(roomName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const handler = this.handlers[roomName];
            if (!handler) {
                throw new Errors_1.MatchMakeError(`no available handler for "${roomName}"`, Protocol_1.Protocol.ERR_MATCHMAKE_NO_HANDLER);
            }
            // Object.keys(handler.options)
            const room = yield this.createRoom(roomName, options);
            return this.reserveSeatFor(room, options);
        });
    }
    join(roomName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const room = yield this.queryRoom(roomName, options);
            if (!room) {
                throw new Errors_1.MatchMakeError(`no rooms found with provided criteria`, Protocol_1.Protocol.ERR_MATCHMAKE_INVALID_CRITERIA);
            }
            return this.reserveSeatFor(room, options);
        });
    }
    joinById(roomId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const isValidRoomId = index_1.isValidId(roomId);
            const room = isValidRoomId && (yield this.driver.findOne({ roomId }));
            if (room) {
                const rejoinSessionId = options.sessionId;
                if (rejoinSessionId) {
                    // handle re-connection!
                    const [_, hasReservedSeat] = yield this.remoteRoomCall(room.roomId, 'hasReservedSeat', [rejoinSessionId]);
                    if (hasReservedSeat) {
                        return { room, sessionId: rejoinSessionId };
                    }
                    else {
                        throw new Errors_1.MatchMakeError(`session expired`, Protocol_1.Protocol.ERR_MATCHMAKE_EXPIRED);
                    }
                }
                else if (!room.locked) {
                    return this.reserveSeatFor(room, options);
                }
                else {
                    throw new Errors_1.MatchMakeError(`room "${roomId}" is locked`, Protocol_1.Protocol.ERR_MATCHMAKE_INVALID_ROOM_ID);
                }
            }
            else {
                throw new Errors_1.MatchMakeError(`room "${roomId}" not found`, Protocol_1.Protocol.ERR_MATCHMAKE_INVALID_ROOM_ID);
            }
        });
    }
    query(roomName, conditions = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (roomName) {
                conditions.name = roomName;
            }
            // list only public rooms
            conditions.private = false;
            return yield this.driver.find(conditions);
        });
    }
    queryRoom(roomName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.awaitRoomAvailable(roomName);
            const handler = this.handlers[roomName];
            if (!handler) {
                throw new Errors_1.MatchMakeError(`no available handler for "${roomName}"`, Protocol_1.Protocol.ERR_MATCHMAKE_NO_HANDLER);
            }
            const query = this.driver.findOne(Object.assign({ locked: false, name: roomName }, handler.getFilterOptions(options)));
            if (handler.sortOptions) {
                query.sort(handler.sortOptions);
            }
            return yield query;
        });
    }
    remoteRoomCall(roomId, method, args, rejectionTimeout = exports.REMOTE_ROOM_SHORT_TIMEOUT) {
        return __awaiter(this, void 0, void 0, function* () {
            const room = this.localRooms[roomId];
            if (!room) {
                return new Promise((resolve, reject) => {
                    let unsubscribeTimeout;
                    const requestId = index_1.generateId();
                    const channel = `${roomId}:${requestId}`;
                    const unsubscribe = () => {
                        this.presence.unsubscribe(channel);
                        clearTimeout(unsubscribeTimeout);
                    };
                    this.presence.subscribe(channel, (message) => {
                        const [code, data] = message;
                        if (code === Protocol_1.IpcProtocol.SUCCESS) {
                            resolve(data);
                        }
                        else if (code === Protocol_1.IpcProtocol.ERROR) {
                            reject(data);
                        }
                        unsubscribe();
                    });
                    this.presence.publish(this.getRoomChannel(roomId), [method, requestId, args]);
                    unsubscribeTimeout = setTimeout(() => {
                        unsubscribe();
                        const request = `${method}${args && ' with args ' + JSON.stringify(args) || ''}`;
                        reject(new Error(`remote room (${roomId}) timed out, requesting "${request}". ` +
                            `Timeout setting: ${rejectionTimeout}ms`));
                    }, rejectionTimeout);
                });
            }
            else {
                return [
                    this.processId,
                    (!args && typeof (room[method]) !== 'function')
                        ? room[method]
                        : (yield room[method].apply(room, args)),
                ];
            }
        });
    }
    defineRoomType(name, klass, defaultOptions = {}) {
        const registeredHandler = new RegisteredHandler_1.RegisteredHandler(klass, defaultOptions);
        this.handlers[name] = registeredHandler;
        this.cleanupStaleRooms(name);
        return registeredHandler;
    }
    hasHandler(name) {
        return this.handlers[name] !== undefined;
    }
    createRoom(roomName, clientOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const registeredHandler = this.handlers[roomName];
            const room = new registeredHandler.klass();
            // set room public attributes
            room.roomId = index_1.generateId();
            room.roomName = roomName;
            room.presence = this.presence;
            // create a RoomCache reference.
            room.listing = this.driver.createInstance(Object.assign({ name: roomName, processId: this.processId, roomId: room.roomId }, registeredHandler.getFilterOptions(clientOptions)));
            if (room.onCreate) {
                try {
                    yield room.onCreate(Utils_1.merge({}, clientOptions, registeredHandler.options));
                }
                catch (e) {
                    Debug_1.debugAndPrintError(e);
                    throw new Errors_1.MatchMakeError(e.message, Protocol_1.Protocol.ERR_MATCHMAKE_UNHANDLED);
                }
            }
            room._internalState = Room_1.RoomInternalState.CREATED;
            room.listing.maxClients = room.maxClients;
            // imediatelly ask client to join the room
            Debug_1.debugMatchMaking('spawning \'%s\', roomId: %s, processId: %s', roomName, room.roomId, this.processId);
            room.on('lock', this.lockRoom.bind(this, roomName, room));
            room.on('unlock', this.unlockRoom.bind(this, roomName, room));
            room.on('join', this.onClientJoinRoom.bind(this, room));
            room.on('leave', this.onClientLeaveRoom.bind(this, room));
            room.once('dispose', this.disposeRoom.bind(this, roomName, room));
            room.once('disconnect', () => room.removeAllListeners());
            // room always start unlocked
            yield this.createRoomReferences(room, true);
            yield room.listing.save();
            registeredHandler.emit('create', room);
            return room.listing;
        });
    }
    // used only for testing purposes
    getRoomById(roomId) {
        return this.localRooms[roomId];
    }
    gracefullyShutdown() {
        if (this.isGracefullyShuttingDown) {
            return Promise.reject(false);
        }
        this.isGracefullyShuttingDown = true;
        const promises = [];
        for (const roomId in this.localRooms) {
            if (!this.localRooms.hasOwnProperty(roomId)) {
                continue;
            }
            const room = this.localRooms[roomId];
            promises.push(room.disconnect());
        }
        return Promise.all(promises);
    }
    reserveSeatFor(room, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const sessionId = index_1.generateId();
            Debug_1.debugMatchMaking('reserving seat. sessionId: \'%s\', roomId: \'%s\', processId: \'%s\'', sessionId, room.roomId, this.processId);
            yield this.remoteRoomCall(room.roomId, '_reserveSeat', [sessionId, options]);
            return { room, sessionId };
        });
    }
    cleanupStaleRooms(roomName) {
        return __awaiter(this, void 0, void 0, function* () {
            //
            // clean-up possibly stale room ids
            // (ungraceful shutdowns using Redis can result on stale room ids still on memory.)
            //
            const cachedRooms = yield this.driver.find({ name: roomName }, { _id: 1 });
            // remove connecting counts
            yield this.presence.del(this.getHandlerConcurrencyKey(roomName));
            yield Promise.all(cachedRooms.map((room) => __awaiter(this, void 0, void 0, function* () {
                try {
                    // use hardcoded short timeout for cleaning up stale rooms.
                    yield this.remoteRoomCall(room.roomId, 'roomId');
                }
                catch (e) {
                    Debug_1.debugMatchMaking(`cleaning up stale room '${roomName}', roomId: ${room.roomId}`);
                    room.remove();
                    this.clearRoomReferences({ roomId: room.roomId, roomName });
                }
            })));
        });
    }
    createRoomReferences(room, init = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.localRooms[room.roomId] = room;
            // add unlocked room reference
            yield this.presence.sadd(room.roomName, room.roomId);
            if (init) {
                yield this.presence.subscribe(this.getRoomChannel(room.roomId), (message) => {
                    const [method, requestId, args] = message;
                    const reply = (code, data) => {
                        this.presence.publish(`${room.roomId}:${requestId}`, [code, [this.processId, data]]);
                    };
                    // reply with property value
                    if (!args && typeof (room[method]) !== 'function') {
                        return reply(Protocol_1.IpcProtocol.SUCCESS, room[method]);
                    }
                    // reply with method result
                    let response;
                    try {
                        response = room[method].apply(room, args);
                    }
                    catch (e) {
                        Debug_1.debugAndPrintError(e.stack || e);
                        return reply(Protocol_1.IpcProtocol.ERROR, e.message || e);
                    }
                    if (!(response instanceof Promise)) {
                        return reply(Protocol_1.IpcProtocol.SUCCESS, response);
                    }
                    response.
                        then((result) => reply(Protocol_1.IpcProtocol.SUCCESS, result)).
                        catch((e) => {
                        // user might have called `reject()` without arguments.
                        const err = e && e.message || e;
                        reply(Protocol_1.IpcProtocol.ERROR, err);
                    });
                });
            }
            return true;
        });
    }
    clearRoomReferences(room) {
        this.presence.srem(room.roomName, room.roomId);
        // clear list of connecting clients.
        this.presence.del(room.roomId);
    }
    awaitRoomAvailable(roomToJoin) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = this.getHandlerConcurrencyKey(roomToJoin);
            const concurrency = (yield this.presence.incr(key)) - 1;
            this.presence.decr(key);
            if (concurrency > 0) {
                // avoid having too long timeout if 10+ clients ask to join at the same time
                const concurrencyTimeout = Math.min(concurrency * 100, exports.REMOTE_ROOM_SHORT_TIMEOUT);
                Debug_1.debugMatchMaking('receiving %d concurrent requests for joining \'%s\' (waiting %d ms)', concurrency, roomToJoin, concurrencyTimeout);
                return yield new Promise((resolve, reject) => setTimeout(resolve, concurrencyTimeout));
            }
            else {
                return true;
            }
        });
    }
    getRoomChannel(roomId) {
        return `$${roomId}`;
    }
    getHandlerConcurrencyKey(name) {
        return `${name}:c`;
    }
    onClientJoinRoom(room, client) {
        this.handlers[room.roomName].emit('join', room, client);
    }
    onClientLeaveRoom(room, client) {
        this.handlers[room.roomName].emit('leave', room, client);
    }
    lockRoom(roomName, room) {
        this.clearRoomReferences(room);
        // emit public event on registered handler
        this.handlers[room.roomName].emit('lock', room);
    }
    unlockRoom(roomName, room) {
        return __awaiter(this, void 0, void 0, function* () {
            if (yield this.createRoomReferences(room)) {
                // emit public event on registered handler
                this.handlers[room.roomName].emit('unlock', room);
            }
        });
    }
    disposeRoom(roomName, room) {
        Debug_1.debugMatchMaking('disposing \'%s\' (%s) on processId \'%s\'', roomName, room.roomId, this.processId);
        // remove from room listing
        room.listing.remove();
        // emit disposal on registered session handler
        this.handlers[roomName].emit('dispose', room);
        // remove concurrency key
        this.presence.del(this.getHandlerConcurrencyKey(roomName));
        // remove from available rooms
        this.clearRoomReferences(room);
        // unsubscribe from remote connections
        this.presence.unsubscribe(this.getRoomChannel(room.roomId));
        // remove actual room reference
        delete this.localRooms[room.roomId];
    }
}
exports.MatchMaker = MatchMaker;
